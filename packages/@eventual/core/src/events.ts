import { DeterminismError } from "./error.js";

export interface BaseEvent {
  type: WorkflowEventType;
  id: string;
  timestamp: string;
}

export interface HistoryEventBase extends BaseEvent {
  seq: number;
}

export enum WorkflowEventType {
  ActivityCompleted = "ActivityCompleted",
  ActivityFailed = "ActivityFailed",
  ActivityScheduled = "ActivityScheduled",
  WorkflowTaskCompleted = "TaskCompleted",
  WorkflowTaskStarted = "TaskStarted",
  WorkflowCompleted = "WorkflowCompleted",
  WorkflowFailed = "WorkflowFailed",
  WorkflowStarted = "WorkflowStarted",
}

/**
 * Events used by the workflow to replay an execution.
 */
export type HistoryEvent =
  | ActivityScheduled
  | ActivityCompleted
  | ActivityFailed;

/**
 * Events that we save into history.
 */
export type HistoryStateEvents = HistoryEvent | WorkflowStarted;

/**
 * Events generated by the engine that represent the in-order state of the workflow.
 */
export type WorkflowEvent =
  | ActivityCompleted
  | ActivityFailed
  | ActivityScheduled
  | WorkflowTaskCompleted
  | WorkflowTaskStarted
  | WorkflowCompleted
  | WorkflowFailed
  | WorkflowStarted;

export interface WorkflowStarted extends BaseEvent {
  type: WorkflowEventType.WorkflowStarted;
  input?: any;
}

export function isWorkflowStarted(
  event: WorkflowEvent
): event is WorkflowStarted {
  return event.type === WorkflowEventType.WorkflowStarted;
}

export interface WorkflowTaskStarted extends BaseEvent {
  type: WorkflowEventType.WorkflowTaskStarted;
}

export function isTaskStarted(
  event: WorkflowEvent
): event is WorkflowTaskStarted {
  return event.type === WorkflowEventType.WorkflowTaskStarted;
}

export interface ActivityScheduled extends HistoryEventBase {
  type: WorkflowEventType.ActivityScheduled;
  name: string;
}

export function isActivityScheduled(
  event: WorkflowEvent
): event is ActivityScheduled {
  return event.type === WorkflowEventType.ActivityScheduled;
}

export interface ActivityCompleted extends HistoryEventBase {
  type: WorkflowEventType.ActivityCompleted;
  // the time from being scheduled until the activity completes.
  duration: number;
  result: any;
}

export function isActivityCompleted(
  event: WorkflowEvent
): event is ActivityCompleted {
  return event.type === WorkflowEventType.ActivityCompleted;
}

export interface ActivityFailed extends HistoryEventBase {
  type: WorkflowEventType.ActivityFailed;
  error: string;
  // the time from being scheduled until the activity completes.
  duration: number;
  message: string;
}

export function isHistoryEvent(event: WorkflowEvent): event is HistoryEvent {
  return (
    isActivityCompleted(event) ||
    isActivityFailed(event) ||
    isActivityScheduled(event)
  );
}

export function isActivityFailed(
  event: WorkflowEvent
): event is ActivityFailed {
  return event.type === WorkflowEventType.ActivityFailed;
}

export interface WorkflowTaskCompleted extends BaseEvent {
  type: WorkflowEventType.WorkflowTaskCompleted;
}

export function isTaskCompleted(
  event: WorkflowEvent
): event is WorkflowTaskCompleted {
  return event.type === WorkflowEventType.WorkflowTaskCompleted;
}

export interface WorkflowCompleted extends BaseEvent {
  type: WorkflowEventType.WorkflowCompleted;
  output: any;
}

export function isWorkflowCompleted(
  event: WorkflowEvent
): event is WorkflowCompleted {
  return event.type === WorkflowEventType.WorkflowCompleted;
}

export interface WorkflowFailed extends BaseEvent {
  type: WorkflowEventType.WorkflowFailed;
  error: string;
  message: string;
}

export function isWorkflowFailed(
  event: WorkflowEvent
): event is WorkflowFailed {
  return event.type === WorkflowEventType.WorkflowFailed;
}

export function assertEventType<T extends WorkflowEvent>(
  event: any,
  type: T["type"]
): asserts event is T {
  if (!event || event.type !== type) {
    throw new Error(`Expected event of type ${type}`);
  }
}

/**
 * Merges two sets of in order events. If the event overlap from events1 to event2, the overlap must be continuos until the end of event1s.
 *
 * This method is used to support the orchestrator consuming events from History and WorkflowTask.
 * When orchestrator invocations fail after history has already been persisted
 * the orchestrator may try to re-process events in the WorkflowTask, leading to duplicate events.
 * Intelligently merge the event series together to avoid duplicate events which wil create determinism errors.
 *
 * e1: 1,2,3
 * e2: 4,5,6
 * result: 1,2,3,4,5,6 - no overlap, concat the arrays
 *
 * e1: 1,2,3
 * e2: 3,4, 5
 * result: 1,2,3,4,5 - the tail of e1 overlaps with the head of e2, take one of the ID:3 events and concat the rest.
 *
 * e1: 1,2,3
 * e2: 2,4,5
 * result: ERROR - Events merge failed, the overlapping events are not continuous. Expected 3 to be next in e2.
 *
 * e1: 1,2,3
 * e2: 2
 * result: ERROR - Events merge failed, the overlapping events are not continuous. Expected 3 to be next in e2.
 */
export function tryMergeEvents<T extends WorkflowEvent>(
  events1: T[],
  events2: T[]
): T[] {
  const trailingIds = new Set(events2.map((e) => e.id));
  const { leading, trailing } = events1.reduce(
    ({ leading, trailing, take }, e1) => {
      const [e2, ...tTail] = trailing;
      // the next leading event matches the head of the trailing events, take from both. Assume the contents are identical.
      if (e1.id === e2?.id) {
        return {
          leading: [...leading, e1],
          trailing: tTail,
          take: true,
        };
      } else if (take || trailingIds.has(e1.id)) {
        // we had started taking from the trailing, but found an event in the leading that was not in the trailing. Events must match continuously.
        throw new DeterminismError(
          `Events merge failed, the overlapping events are not continuous, expected ${e1.id} next in the trailing events, found ${e2?.id}.`
        );
      } else {
        // leading event is not in the trailing yet, keep taking from leading.
        return {
          leading: [...leading, e1],
          trailing,
          take,
        };
      }
    },
    { leading: [] as typeof events1, trailing: events2, take: false }
  );

  return [...leading, ...trailing];
}
