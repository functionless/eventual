import type { EventEnvelope } from "../event.js";
import type { WorkflowExecutionContext } from "../workflow.js";
import type { EntityOperation } from "./calls/entity-call.js";
import { or } from "./util.js";

export interface BaseEvent {
  type: WorkflowEventType;
  id: string;
  timestamp: string;
}

/**
 * Common fields for events that {@link Eventual} actives with in order semantics.
 */
export interface HistoryEventBase extends Omit<BaseEvent, "id"> {
  seq: number;
}

export enum WorkflowEventType {
  ChildWorkflowSucceeded = "ChildWorkflowSucceeded",
  ChildWorkflowFailed = "ChildWorkflowFailed",
  ChildWorkflowScheduled = "ChildWorkflowScheduled",
  EntityRequest = "EntityRequest",
  EntityRequestFailed = "EntityRequestFailed",
  EntityRequestSucceeded = "EntityRequestSucceeded",
  EventsPublished = "EventsPublished",
  TransactionRequest = "InvokeTransactionRequest",
  TransactionRequestFailed = "InvokeTransactionRequestFailed",
  TransactionRequestSucceeded = "InvokeTransactionRequestSucceeded",
  SignalReceived = "SignalReceived",
  SignalSent = "SignalSent",
  TaskSucceeded = "TaskSucceeded",
  TaskFailed = "TaskFailed",
  TaskHeartbeatTimedOut = "TaskHeartbeatTimedOut",
  TaskScheduled = "TaskScheduled",
  TimerCompleted = "TimerCompleted",
  TimerScheduled = "TimerScheduled",
  WorkflowSucceeded = "WorkflowSucceeded",
  WorkflowFailed = "WorkflowFailed",
  WorkflowStarted = "WorkflowStarted",
  WorkflowRunCompleted = "WorkflowRunCompleted",
  WorkflowRunStarted = "WorkflowRunStarted",
  WorkflowTimedOut = "WorkflowTimedOut",
}

/**
 * Events generated by the engine that represent the in-order state of the workflow.
 */
export type WorkflowEvent =
  | HistoryEvent
  | WorkflowRunCompleted
  | WorkflowSucceeded
  | WorkflowFailed
  | WorkflowStarted;

/**
 * Events generated by the workflow to maintain deterministic executions.
 */
export type ScheduledEvent =
  | ChildWorkflowScheduled
  | EntityRequest
  | EventsPublished
  | SignalSent
  | TaskScheduled
  | TimerScheduled
  | TransactionRequest;

export const isScheduledEvent = /* @__PURE__ */ or(
  isChildWorkflowScheduled,
  isEventsPublished,
  isEntityRequest,
  isSignalSent,
  isTaskScheduled,
  isTimerScheduled,
  isTransactionRequest
);

/**
 * Events generated outside of the interpreter which progress the workflow.
 */
export type CompletionEvent =
  | ChildWorkflowFailed
  | ChildWorkflowSucceeded
  | EntityRequestFailed
  | EntityRequestSucceeded
  | SignalReceived
  | TaskFailed
  | TaskHeartbeatTimedOut
  | TaskSucceeded
  | TimerCompleted
  | TransactionRequestSucceeded
  | TransactionRequestFailed
  | WorkflowTimedOut
  | WorkflowRunStarted;

/**
 * All events which can be input into the workflow.
 */
export type WorkflowInputEvent = CompletionEvent | WorkflowStarted;

export const isCompletionEvent = /* @__PURE__ */ or(
  isChildWorkflowFailed,
  isChildWorkflowSucceeded,
  isEntityRequestFailed,
  isEntityRequestSucceeded,
  isSignalReceived,
  isTaskSucceeded,
  isTaskFailed,
  isTaskHeartbeatTimedOut,
  isTimerCompleted,
  isTransactionRequestFailed,
  isTransactionRequestSucceeded,
  isWorkflowTimedOut,
  isWorkflowRunStarted
);

/**
 * Events used by the workflow to replay an execution.
 */
export type HistoryEvent = CompletionEvent | ScheduledEvent;

export function isHistoryEvent(event: WorkflowEvent): event is HistoryEvent {
  return isCompletionEvent(event) || isScheduledEvent(event);
}

/**
 * Events that we save into history.
 */
export type HistoryStateEvent =
  | HistoryEvent
  | WorkflowStarted
  | WorkflowSucceeded
  | WorkflowFailed;

export function isHistoryStateEvent(
  event: WorkflowEvent
): event is HistoryStateEvent {
  return (
    isHistoryEvent(event) ||
    isWorkflowStarted(event) ||
    isWorkflowSucceeded(event) ||
    isWorkflowFailed(event)
  );
}

export interface WorkflowStarted extends BaseEvent {
  type: WorkflowEventType.WorkflowStarted;
  /**
   * Name of the workflow to execute.
   */
  workflowName: string;
  /**
   * Input payload for the workflow function.
   */
  input?: any;
  /**
   * Optional ISO timestamp after which the workflow should timeout.
   */
  timeoutTime?: string;
  context: Omit<WorkflowExecutionContext, "id" | "startTime">;
}
export interface WorkflowRunStarted extends BaseEvent {
  type: WorkflowEventType.WorkflowRunStarted;
}

export interface TaskScheduled extends HistoryEventBase {
  type: WorkflowEventType.TaskScheduled;
  name: string;
}

export interface TaskSucceeded extends HistoryEventBase {
  type: WorkflowEventType.TaskSucceeded;
  result: any;
}

export interface TaskFailed extends HistoryEventBase {
  type: WorkflowEventType.TaskFailed;
  error: string;
  message?: string;
}

export interface TaskHeartbeatTimedOut extends HistoryEventBase {
  type: WorkflowEventType.TaskHeartbeatTimedOut;
}

export interface WorkflowRunCompleted extends BaseEvent {
  type: WorkflowEventType.WorkflowRunCompleted;
}

export interface WorkflowSucceeded extends BaseEvent {
  type: WorkflowEventType.WorkflowSucceeded;
  output: any;
}

export interface WorkflowFailed extends BaseEvent {
  type: WorkflowEventType.WorkflowFailed;
  error: string;
  message: string;
}

export interface ChildWorkflowScheduled extends HistoryEventBase {
  type: WorkflowEventType.ChildWorkflowScheduled;
  name: string;
  input?: any;
}

export interface ChildWorkflowSucceeded extends HistoryEventBase {
  type: WorkflowEventType.ChildWorkflowSucceeded;
  result: any;
}

export interface ChildWorkflowFailed extends HistoryEventBase {
  type: WorkflowEventType.ChildWorkflowFailed;
  error: string;
  message: string;
}

export function isWorkflowStarted(
  event: WorkflowEvent
): event is WorkflowStarted {
  return event.type === WorkflowEventType.WorkflowStarted;
}

export function isWorkflowRunStarted(
  event: WorkflowEvent
): event is WorkflowRunStarted {
  return event.type === WorkflowEventType.WorkflowRunStarted;
}

export function isTaskScheduled(event: WorkflowEvent): event is TaskScheduled {
  return event.type === WorkflowEventType.TaskScheduled;
}

export function isTaskSucceeded(event: WorkflowEvent): event is TaskSucceeded {
  return event.type === WorkflowEventType.TaskSucceeded;
}

export function isTaskFailed(event: WorkflowEvent): event is TaskFailed {
  return event.type === WorkflowEventType.TaskFailed;
}

export function isTaskHeartbeatTimedOut(
  event: WorkflowEvent
): event is TaskHeartbeatTimedOut {
  return event.type === WorkflowEventType.TaskHeartbeatTimedOut;
}

export interface EntityRequest extends HistoryEventBase {
  type: WorkflowEventType.EntityRequest;
  operation: EntityOperation;
}

export interface EntityRequestSucceeded extends HistoryEventBase {
  type: WorkflowEventType.EntityRequestSucceeded;
  name?: string;
  operation: EntityOperation["operation"];
  result: any;
}

export interface EntityRequestFailed extends HistoryEventBase {
  type: WorkflowEventType.EntityRequestFailed;
  operation: EntityOperation["operation"];
  name?: string;
  error: string;
  message: string;
}

export function isEntityRequest(event: WorkflowEvent): event is EntityRequest {
  return event.type === WorkflowEventType.EntityRequest;
}

export function isEntityRequestSucceeded(
  event: WorkflowEvent
): event is EntityRequestSucceeded {
  return event.type === WorkflowEventType.EntityRequestSucceeded;
}

export function isEntityRequestFailed(
  event: WorkflowEvent
): event is EntityRequestFailed {
  return event.type === WorkflowEventType.EntityRequestFailed;
}

export interface TransactionRequest extends HistoryEventBase {
  type: WorkflowEventType.TransactionRequest;
  input: any;
  transactionName: string;
}

export interface TransactionRequestSucceeded extends HistoryEventBase {
  type: WorkflowEventType.TransactionRequestSucceeded;
  result: any;
}

export interface TransactionRequestFailed extends HistoryEventBase {
  type: WorkflowEventType.TransactionRequestFailed;
  error: string;
  message: string;
}

export function isTransactionRequest(
  event: WorkflowEvent
): event is TransactionRequest {
  return event.type === WorkflowEventType.TransactionRequest;
}

export function isTransactionRequestSucceeded(
  event: WorkflowEvent
): event is TransactionRequestSucceeded {
  return event.type === WorkflowEventType.TransactionRequestSucceeded;
}

export function isTransactionRequestFailed(
  event: WorkflowEvent
): event is TransactionRequestFailed {
  return event.type === WorkflowEventType.TransactionRequestFailed;
}

export interface TimerScheduled extends HistoryEventBase {
  type: WorkflowEventType.TimerScheduled;
  untilTime: string;
}

export function isTimerScheduled(
  event: WorkflowEvent
): event is TimerScheduled {
  return event.type === WorkflowEventType.TimerScheduled;
}

export interface TimerCompleted extends HistoryEventBase {
  type: WorkflowEventType.TimerCompleted;
  result?: undefined;
}

export function isWorkflowRunCompleted(
  event: WorkflowEvent
): event is WorkflowRunCompleted {
  return event.type === WorkflowEventType.WorkflowRunCompleted;
}

export function isWorkflowSucceeded(
  event: WorkflowEvent
): event is WorkflowSucceeded {
  return event.type === WorkflowEventType.WorkflowSucceeded;
}

export function isWorkflowFailed(
  event: WorkflowEvent
): event is WorkflowFailed {
  return event.type === WorkflowEventType.WorkflowFailed;
}

export function isChildWorkflowScheduled(
  event: WorkflowEvent
): event is ChildWorkflowScheduled {
  return event.type === WorkflowEventType.ChildWorkflowScheduled;
}
export function isChildWorkflowSucceeded(
  event: WorkflowEvent
): event is ChildWorkflowSucceeded {
  return event.type === WorkflowEventType.ChildWorkflowSucceeded;
}
export function isChildWorkflowFailed(
  event: WorkflowEvent
): event is ChildWorkflowFailed {
  return event.type === WorkflowEventType.ChildWorkflowFailed;
}

export function isTimerCompleted(
  event: WorkflowEvent
): event is TimerCompleted {
  return event.type === WorkflowEventType.TimerCompleted;
}

export const isWorkflowCompletedEvent = or(
  isWorkflowFailed,
  isWorkflowSucceeded
);

export interface SignalReceived<Payload = any> extends BaseEvent {
  type: WorkflowEventType.SignalReceived;
  signalId: string;
  payload?: Payload;
}

export function isSignalReceived(
  event: WorkflowEvent
): event is SignalReceived {
  return event.type === WorkflowEventType.SignalReceived;
}

export interface SignalSent extends HistoryEventBase {
  type: WorkflowEventType.SignalSent;
  payload?: any;
  signalId: string;
  executionId: string;
}

export function isSignalSent(event: WorkflowEvent): event is SignalSent {
  return event.type === WorkflowEventType.SignalSent;
}

export interface EventsPublished extends HistoryEventBase {
  type: WorkflowEventType.EventsPublished;
  events: EventEnvelope[];
}

export function isEventsPublished(
  event: WorkflowEvent
): event is EventsPublished {
  return event.type === WorkflowEventType.EventsPublished;
}

export interface WorkflowTimedOut extends BaseEvent {
  type: WorkflowEventType.WorkflowTimedOut;
}

export function isWorkflowTimedOut(
  event: WorkflowEvent
): event is WorkflowTimedOut {
  return event.type === WorkflowEventType.WorkflowTimedOut;
}

export function assertEventType<T extends WorkflowEvent>(
  event: any,
  type: T["type"]
): asserts event is T {
  if (!event || event.type !== type) {
    throw new Error(`Expected event of type ${type}`);
  }
}

/**
 * Compute the ID of an event.
 *
 * Some events have a computed ID to save space.
 */
export function getEventId(event: WorkflowEvent): string {
  if (isHistoryEvent(event) && "seq" in event) {
    return `${event.seq}_${event.type}`;
  } else {
    return event.id;
  }
}
