import type { EventEnvelope } from "../event.js";
import type { WorkflowExecutionContext } from "../workflow.js";
import type { DictionaryOperation } from "./calls/dictionary-call.js";
import { or } from "./util.js";

export interface BaseEvent {
  type: WorkflowEventType;
  id: string;
  timestamp: string;
}

/**
 * Common fields for events that {@link Eventual} actives with in order semantics.
 */
export interface HistoryEventBase extends Omit<BaseEvent, "id"> {
  seq: number;
}

export enum WorkflowEventType {
  ActivitySucceeded = "ActivitySucceeded",
  ActivityFailed = "ActivityFailed",
  ActivityHeartbeatTimedOut = "ActivityHeartbeatTimedOut",
  ActivityScheduled = "ActivityScheduled",
  ChildWorkflowSucceeded = "ChildWorkflowSucceeded",
  ChildWorkflowFailed = "ChildWorkflowFailed",
  ChildWorkflowScheduled = "ChildWorkflowScheduled",
  DictionaryRequest = "DictionaryRequest",
  DictionaryRequestFailed = "DictionaryRequestFailed",
  DictionaryRequestSucceeded = "DictionaryRequestSucceeded",
  EventsPublished = "EventsPublished",
  TransactionRequest = "InvokeTransactionRequest",
  TransactionRequestFailed = "InvokeTransactionRequestFailed",
  TransactionRequestSucceeded = "InvokeTransactionRequestSucceeded",
  SignalReceived = "SignalReceived",
  SignalSent = "SignalSent",
  TimerCompleted = "TimerCompleted",
  TimerScheduled = "TimerScheduled",
  WorkflowSucceeded = "WorkflowSucceeded",
  WorkflowFailed = "WorkflowFailed",
  WorkflowStarted = "WorkflowStarted",
  WorkflowRunCompleted = "WorkflowRunCompleted",
  WorkflowRunStarted = "WorkflowRunStarted",
  WorkflowTimedOut = "WorkflowTimedOut",
}

/**
 * Events generated by the engine that represent the in-order state of the workflow.
 */
export type WorkflowEvent =
  | HistoryEvent
  | WorkflowRunCompleted
  | WorkflowSucceeded
  | WorkflowFailed
  | WorkflowStarted;

/**
 * Events generated by the workflow to maintain deterministic executions.
 */
export type ScheduledEvent =
  | ActivityScheduled
  | ChildWorkflowScheduled
  | DictionaryRequest
  | EventsPublished
  | SignalSent
  | TimerScheduled
  | TransactionRequest;

export const isScheduledEvent = /* @__PURE__ */ or(
  isActivityScheduled,
  isChildWorkflowScheduled,
  isEventsPublished,
  isDictionaryRequest,
  isSignalSent,
  isTimerScheduled,
  isTransactionRequest
);

/**
 * Events generated outside of the interpreter which progress the workflow.
 */
export type CompletionEvent =
  | ActivityFailed
  | ActivityHeartbeatTimedOut
  | ActivitySucceeded
  | ChildWorkflowFailed
  | ChildWorkflowSucceeded
  | DictionaryRequestFailed
  | DictionaryRequestSucceeded
  | SignalReceived
  | TimerCompleted
  | TransactionRequestSucceeded
  | TransactionRequestFailed
  | WorkflowTimedOut
  | WorkflowRunStarted;

/**
 * All events which can be input into the workflow.
 */
export type WorkflowInputEvent = CompletionEvent | WorkflowStarted;

export const isCompletionEvent = /* @__PURE__ */ or(
  isActivitySucceeded,
  isActivityFailed,
  isActivityHeartbeatTimedOut,
  isChildWorkflowFailed,
  isChildWorkflowSucceeded,
  isDictionaryRequestFailed,
  isDictionaryRequestSucceeded,
  isSignalReceived,
  isTimerCompleted,
  isTransactionRequestFailed,
  isTransactionRequestSucceeded,
  isWorkflowTimedOut,
  isWorkflowRunStarted
);

/**
 * Events used by the workflow to replay an execution.
 */
export type HistoryEvent = CompletionEvent | ScheduledEvent;

export function isHistoryEvent(event: WorkflowEvent): event is HistoryEvent {
  return isCompletionEvent(event) || isScheduledEvent(event);
}

/**
 * Events that we save into history.
 */
export type HistoryStateEvent =
  | HistoryEvent
  | WorkflowStarted
  | WorkflowSucceeded
  | WorkflowFailed;

export function isHistoryStateEvent(
  event: WorkflowEvent
): event is HistoryStateEvent {
  return (
    isHistoryEvent(event) ||
    isWorkflowStarted(event) ||
    isWorkflowSucceeded(event) ||
    isWorkflowFailed(event)
  );
}

export interface WorkflowStarted extends BaseEvent {
  type: WorkflowEventType.WorkflowStarted;
  /**
   * Name of the workflow to execute.
   */
  workflowName: string;
  /**
   * Input payload for the workflow function.
   */
  input?: any;
  /**
   * Optional ISO timestamp after which the workflow should timeout.
   */
  timeoutTime?: string;
  context: Omit<WorkflowExecutionContext, "id" | "startTime">;
}
export interface WorkflowRunStarted extends BaseEvent {
  type: WorkflowEventType.WorkflowRunStarted;
}

export interface ActivityScheduled extends HistoryEventBase {
  type: WorkflowEventType.ActivityScheduled;
  name: string;
}

export interface ActivitySucceeded extends HistoryEventBase {
  type: WorkflowEventType.ActivitySucceeded;
  result: any;
}

export interface ActivityFailed extends HistoryEventBase {
  type: WorkflowEventType.ActivityFailed;
  error: string;
  message?: string;
}

export interface ActivityHeartbeatTimedOut extends HistoryEventBase {
  type: WorkflowEventType.ActivityHeartbeatTimedOut;
}

export interface WorkflowRunCompleted extends BaseEvent {
  type: WorkflowEventType.WorkflowRunCompleted;
}

export interface WorkflowSucceeded extends BaseEvent {
  type: WorkflowEventType.WorkflowSucceeded;
  output: any;
}

export interface WorkflowFailed extends BaseEvent {
  type: WorkflowEventType.WorkflowFailed;
  error: string;
  message: string;
}

export interface ChildWorkflowScheduled extends HistoryEventBase {
  type: WorkflowEventType.ChildWorkflowScheduled;
  name: string;
  input?: any;
}

export interface ChildWorkflowSucceeded extends HistoryEventBase {
  type: WorkflowEventType.ChildWorkflowSucceeded;
  result: any;
}

export interface ChildWorkflowFailed extends HistoryEventBase {
  type: WorkflowEventType.ChildWorkflowFailed;
  error: string;
  message: string;
}

export function isWorkflowStarted(
  event: WorkflowEvent
): event is WorkflowStarted {
  return event.type === WorkflowEventType.WorkflowStarted;
}

export function isWorkflowRunStarted(
  event: WorkflowEvent
): event is WorkflowRunStarted {
  return event.type === WorkflowEventType.WorkflowRunStarted;
}

export function isActivityScheduled(
  event: WorkflowEvent
): event is ActivityScheduled {
  return event.type === WorkflowEventType.ActivityScheduled;
}

export function isActivitySucceeded(
  event: WorkflowEvent
): event is ActivitySucceeded {
  return event.type === WorkflowEventType.ActivitySucceeded;
}

export function isActivityFailed(
  event: WorkflowEvent
): event is ActivityFailed {
  return event.type === WorkflowEventType.ActivityFailed;
}

export function isActivityHeartbeatTimedOut(
  event: WorkflowEvent
): event is ActivityHeartbeatTimedOut {
  return event.type === WorkflowEventType.ActivityHeartbeatTimedOut;
}

export interface DictionaryRequest extends HistoryEventBase {
  type: WorkflowEventType.DictionaryRequest;
  operation: DictionaryOperation;
}

export interface DictionaryRequestSucceeded extends HistoryEventBase {
  type: WorkflowEventType.DictionaryRequestSucceeded;
  name?: string;
  operation: DictionaryOperation["operation"];
  result: any;
}

export interface DictionaryRequestFailed extends HistoryEventBase {
  type: WorkflowEventType.DictionaryRequestFailed;
  operation: DictionaryOperation["operation"];
  name?: string;
  error: string;
  message: string;
}

export function isDictionaryRequest(
  event: WorkflowEvent
): event is DictionaryRequest {
  return event.type === WorkflowEventType.DictionaryRequest;
}

export function isDictionaryRequestSucceeded(
  event: WorkflowEvent
): event is DictionaryRequestSucceeded {
  return event.type === WorkflowEventType.DictionaryRequestSucceeded;
}

export function isDictionaryRequestFailed(
  event: WorkflowEvent
): event is DictionaryRequestFailed {
  return event.type === WorkflowEventType.DictionaryRequestFailed;
}

export interface TransactionRequest extends HistoryEventBase {
  type: WorkflowEventType.TransactionRequest;
  input: any;
  transactionName: string;
}

export interface TransactionRequestSucceeded extends HistoryEventBase {
  type: WorkflowEventType.TransactionRequestSucceeded;
  result: any;
}

export interface TransactionRequestFailed extends HistoryEventBase {
  type: WorkflowEventType.TransactionRequestFailed;
  error: string;
  message: string;
}

export function isTransactionRequest(
  event: WorkflowEvent
): event is TransactionRequest {
  return event.type === WorkflowEventType.TransactionRequest;
}

export function isTransactionRequestSucceeded(
  event: WorkflowEvent
): event is TransactionRequestSucceeded {
  return event.type === WorkflowEventType.TransactionRequestSucceeded;
}

export function isTransactionRequestFailed(
  event: WorkflowEvent
): event is TransactionRequestFailed {
  return event.type === WorkflowEventType.TransactionRequestFailed;
}

export interface TimerScheduled extends HistoryEventBase {
  type: WorkflowEventType.TimerScheduled;
  untilTime: string;
}

export function isTimerScheduled(
  event: WorkflowEvent
): event is TimerScheduled {
  return event.type === WorkflowEventType.TimerScheduled;
}

export interface TimerCompleted extends HistoryEventBase {
  type: WorkflowEventType.TimerCompleted;
  result?: undefined;
}

export function isWorkflowRunCompleted(
  event: WorkflowEvent
): event is WorkflowRunCompleted {
  return event.type === WorkflowEventType.WorkflowRunCompleted;
}

export function isWorkflowSucceeded(
  event: WorkflowEvent
): event is WorkflowSucceeded {
  return event.type === WorkflowEventType.WorkflowSucceeded;
}

export function isWorkflowFailed(
  event: WorkflowEvent
): event is WorkflowFailed {
  return event.type === WorkflowEventType.WorkflowFailed;
}

export function isChildWorkflowScheduled(
  event: WorkflowEvent
): event is ChildWorkflowScheduled {
  return event.type === WorkflowEventType.ChildWorkflowScheduled;
}
export function isChildWorkflowSucceeded(
  event: WorkflowEvent
): event is ChildWorkflowSucceeded {
  return event.type === WorkflowEventType.ChildWorkflowSucceeded;
}
export function isChildWorkflowFailed(
  event: WorkflowEvent
): event is ChildWorkflowFailed {
  return event.type === WorkflowEventType.ChildWorkflowFailed;
}

export function isTimerCompleted(
  event: WorkflowEvent
): event is TimerCompleted {
  return event.type === WorkflowEventType.TimerCompleted;
}

export const isWorkflowCompletedEvent = or(
  isWorkflowFailed,
  isWorkflowSucceeded
);

export interface SignalReceived<Payload = any> extends BaseEvent {
  type: WorkflowEventType.SignalReceived;
  signalId: string;
  payload?: Payload;
}

export function isSignalReceived(
  event: WorkflowEvent
): event is SignalReceived {
  return event.type === WorkflowEventType.SignalReceived;
}

export interface SignalSent extends HistoryEventBase {
  type: WorkflowEventType.SignalSent;
  payload?: any;
  signalId: string;
  executionId: string;
}

export function isSignalSent(event: WorkflowEvent): event is SignalSent {
  return event.type === WorkflowEventType.SignalSent;
}

export interface EventsPublished extends HistoryEventBase {
  type: WorkflowEventType.EventsPublished;
  events: EventEnvelope[];
}

export function isEventsPublished(
  event: WorkflowEvent
): event is EventsPublished {
  return event.type === WorkflowEventType.EventsPublished;
}

export interface WorkflowTimedOut extends BaseEvent {
  type: WorkflowEventType.WorkflowTimedOut;
}

export function isWorkflowTimedOut(
  event: WorkflowEvent
): event is WorkflowTimedOut {
  return event.type === WorkflowEventType.WorkflowTimedOut;
}

export function assertEventType<T extends WorkflowEvent>(
  event: any,
  type: T["type"]
): asserts event is T {
  if (!event || event.type !== type) {
    throw new Error(`Expected event of type ${type}`);
  }
}

/**
 * Compute the ID of an event.
 *
 * Some events have a computed ID to save space.
 */
export function getEventId(event: WorkflowEvent): string {
  if (isHistoryEvent(event) && "seq" in event) {
    return `${event.seq}_${event.type}`;
  } else {
    return event.id;
  }
}
