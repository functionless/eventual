# Workflow Patterns

This section contains a list of useful patterns that can be applied in workflows.

### Run a sub-procedure

Workflow functions can contain nested functions defined within the workflow that can be called.

```ts
workflow("foo", async () => {
  await subProcedure(1);
  await subProcedure(2);

  async function subProcedure(input) {
    const a = await taskA(input);
    return taskB(a);
  }
});
```

### Recursive functions

Functions can be called recursively, like you'd expect:

```ts
workflow("foo", async () => {
  await retryTask(3);

  async function retryTask(attemptsLeft: number) {
    try {
      await taskA();
    } catch {
      if (attemptsLeft > 0) {
        await retry(attemptsLeft - 1);
      }
    }
  }
});
```

## Event Loop

A `while` loop and a `signal` can be used to build an event loop workflow that waits for an event to come in, takes some action and then waits for the next event.

```ts
type GameEvent = MoveLeft | MoveRight | Done;
interface Done {
  type: "Done";
}
interface MoveLeft {
  type: "MoveLeft";
  amount: number;
}
interface MoveRight {
  type: "MoveRight";
  amount: number;
}

const gameEvent = signal<GameEvent>("GameEvent");

const game = workflow("game", async () => {
  let position = 0;
  while (true) {
    const event = await gameEvent.expect();
    if (event.type === "Done") {
      break;
    } else if (event.type === "MoveLeft") {
      position -= event.amount;
    } else {
      position += event.amount;
    }
  }
});
```

## Concurrency Patterns

Workflows can make use of Node's [`Promise`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) utility functions such as `Promise.all`, `Promise.allSettled`, `Promise.any` and `Promise.race` to orchestrate complex concurrency patterns.

### Run two activities in parallel and wait for both to complete

[`Promise.all`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all) can be used to wait for two parallel activities to complete.

```ts
const [a, b] = await Promise.all([activityA(), activityB()]);
```

### Run two sub-procedures in parallel and wait for both to complete

[`Promise.all`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all) can also be used to wait for parallel sun-procedures to complete:

```ts
workflow("a and b", async () => {
  await Promise.all([a(), b()]);

  async function a() {
    await task1();

    await task2();
  }

  async function b() {
    await task3();

    await task4();
  }
});
```

### Wait x seconds for a condition to be true

[`Promise.race`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race) is a useful primitive for selecting the first of many parallel operations to complete.

```ts
let isCancelled = false;

cancelSignal.on(() => (isCancelled = true));

await Promise.race([
  // sleep while some condition is true
  sleepWhile(() => !isCancelled),
  // sleep for 10s
  sleepFor(10, "seconds"),
]);
```

### Wait for a condition to be true or for a specific date to occur

```ts
let isCancelled = false;

cancelSignal.on(() => (isCancelled = true));

await Promise.race([
  // sleep while some condition is true
  sleepWhile(() => !isCancelled),
  // sleep until the first of january, 2013
  sleepUntil("2013-01-01T00:00Z"),
]);
```

### Select the first procedure to complete

```ts
const aOrB = await Promise.race([a(), b()]);
```

### Select the first procedure to complete successfully

[`Promise.any`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/any) is slightly different than `Promise.race` in that it will select the first Promise to resolve successfully. Promise.race will select the first Promise to resolve (successfully or failed). If all Promises fail then an

```ts
const aOrB = await Promise.any([a(), b()]);
```
